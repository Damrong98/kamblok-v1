{% extends "layout.html" %}

{% block title %}Dynamic Chat UI{% endblock %}

{% block style %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<style>
    .chat_container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 60px); /* Full viewport height */
        /* height: calc(100% - 100px); */
        justify-content: center;
    }

    /* box 01 */
    .scrollable_chat {
        flex-grow: 1; /* Takes available space */
        overflow-y: auto; /* Makes it scrollable */
        /* background-color: lightblue; */
        padding: 10px 20px;
    }
    .chat_content{
        /* background-color: rgb(143, 226, 143); */
        /* max-width: 720px; */
        max-width: 48rem;
        margin: auto;
    }

    /* box 02 */
    .chat_input {
        /* background-color: steelblue; */
        cursor: text; /* Indicates text input */
        padding: 0 20px;
        
    }
    .chat_box_content{
        background-color: aliceblue;
        /* max-width: 720px; */
        max-width: 48rem;
        margin: auto;
        border: 1px darkgray solid;
        border-radius: 20px;
        overflow: hidden;
        padding: 10px 20px;
    }
    .text_box {
        width: 100%;
        height: auto;
        resize: none;
        overflow-x: hidden;
        overflow-y: auto;
        padding: 0;
        border: none;
        outline: none;
        line-height: 20px;
        font-size: 16px;
        line-height: 1.5;
        margin: 10px 0;
        background-color: aliceblue;
    }
    /* Make the scrollbar thin */
    .text_box::-webkit-scrollbar {
        width: 6px; /* Adjust the width */
        height: 6px; /* For horizontal scrollbars */
    }
    .text_box::-webkit-scrollbar-track {
        background: #f1f1f1; /* Light gray background */
        border-radius: 10px;
    }

    /* Scrollbar Thumb (draggable part) */
    .text_box::-webkit-scrollbar-thumb {
        background: #888; /* Darker gray */
        border-radius: 10px;
        cursor: grab; /* Makes the scrollbar draggable */
    }

    /* On hover, make the thumb slightly darker */
    .text_box::-webkit-scrollbar-thumb:hover {
        background: #555;
        cursor: grabbing; /* When actively dragging */
    }

    /* Style on chat */
    .user{
        display: flex;
        justify-content: end;
        margin-bottom: 20px;
        
    }
    .user > div{
        background-color: goldenrod;
        border-radius: 20px;
        padding: 10px 20px;
    }
    .model{
        margin-bottom: 20px;
    }

    /* Action */
    .action_button_container{
        display: flex;
        justify-content: space-between;
    }
    .btn_custom{
        border: 0.1px solid gray;
        background-color: burlywood;
        border-radius: 20px;
        padding: 5px 15px;
    }

    .loading {
            /* font-size: 2rem; */
            /* font-weight: bold; */
            display: flex;
        }
    .loading span {
        animation: blink 1.5s infinite;
    }
    .loading span:nth-child(1) { animation-delay: 0s; }
    .loading span:nth-child(2) { animation-delay: 0.2s; }
    .loading span:nth-child(3) { animation-delay: 0.4s; }
    .loading span:nth-child(4) { animation-delay: 0.6s; }
    .loading span:nth-child(5) { animation-delay: 0.8s; }
    .loading span:nth-child(6) { animation-delay: 1s; }
    .loading span:nth-child(7) { animation-delay: 1.2s; }
    .loading span:nth-child(8) { animation-delay: 1.4s; }
    .loading span:nth-child(9) { animation-delay: 1.6s; }

    @keyframes blink {
        0% { opacity: 0; }
        50% { opacity: 1; }
        100% { opacity: 0; }
    }

    .scroll-to-bottom {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: none; /* Hidden by default */
        z-index: 10; /* Ensure it’s above other content */
        border: 0.1px solid gray;
        border-radius: 20px;
        padding: 5px 15px;
        cursor: pointer;
    }
    .scroll-to-bottom svg {
        vertical-align: middle;
    }

    /* For the mark-down */
    .markdown-content {
        margin-left: 20px;
    }
    /* .markdown-content ul li::marker {
        content: "➤  "; 
        color: #333;
    } */
    .markdown-content>div ul li::marker {
        content: "❖  ";
        color: #333;
    }
    .markdown-content>div>div ul li::marker {
        content: "-  ";
        color: #333;
    }

    /* Table */
    .markdown-content ol li::marker {
        content: counter(list-item) ". "; /* Keeps numbers, or replace with a symbol */
        color: #333;
    }

    .markdown-table {
        border-collapse: collapse;
        margin: 1em 0;
        width: 100%;
    }
    .markdown-th, .markdown-td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    .markdown-th {
        background-color: #f5f5f5;
        font-weight: bold;
    }
   
</style>
{% endblock %}

{% block content %}
<div id="chatContainer" class="chat_container">
    <div id="titleResult"></div>
    <div style="position: relative;">

        <div id="chatMessage" class="scrollable_chat">
            <div class="chat_content">
                <div class=" text-center mb-4" >
                    <h1>How can I help you today?</h1>
            
                </div> 
                <div id="showMessage">
                    <!-- {% for message in chat_history %} -->
                        <div class="{{ message.role }}">
                            <div class="role_box">
                                <!-- For text use this => {{ message.content }} -->
                                <!-- For html user this => {{ message.content | safe}} -->
                                <!-- <strong>{{ message.role|capitalize }}:</strong>  -->
                                <!-- {{ message.content | safe}} -->
                            </div>
                        </div>
                    <!-- {% endfor %} -->
                </div>
            </div>  
        </div>

        <!-- Add Scroll to Bottom button here -->
        <button id="scrollToBottomBtn" class="btn btn-sm btn-primary p-1 scroll-to-bottom" onclick="scrollToBottomManually()">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 5v14" />
                <polyline points="19 12 12 19 5 12" />
            </svg>
            <!-- Scroll to Bottom -->
        </button>

    </div>

    <div id="chatInput" class="chat_input">

        <div class="chat_box_content">
            <textarea id="userPrompt" class="text_box"  rows="1" placeholder="Type something..."></textarea>
            <div class="action_button_container">
                <div class="action1">
                    <button class="btn btn-sm btn-primary" onclick="addEditableForm()">Prompts</button>
                </div>
                <div class="action2">
                    <button id="toggleButton" class="btn btn-sm btn-primary" onclick="toggleChat()">
                        <!-- Start Chat -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 19V5" />
                            <polyline points="5 12 12 5 19 12" />
                        </svg>
                    </button>
                    <!-- <button class="btn" onclick="clearChat()">Clear chat</button> -->
                </div>
            </div>
        </div>
        <div class="p-1 text-center">hello</div>
    </div>
</div>




<script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.2/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<script>
    /*
    * Markdown IT
    * Description: 
    * Use: use in steamResponse
    * 
    */
    const md = window.markdownit({
        html: true,
        breaks: true,
        highlight: function (str, lang) {
            if (lang && window.hljs?.getLanguage(lang)) {
                // If a valid language is detected, format as highlighted code
                return `<pre><code class="hljs">${window.hljs.highlight(str, { language: lang }).value}</code></pre>`;
            }
            // Return null to bypass default code block rendering
            return null;
        }
    });

    // LIST
    // Override the default code_block and fence rendering
    md.renderer.rules.code_block = function (tokens, idx, options, env, self) {
        const token = tokens[idx];
        const content = token.content;
        // Use md.render() for block-level content, wrapped once
        return `<div class="markdown-content">${md.render(content)}</div>`;
    };

    md.renderer.rules.fence = function (tokens, idx, options, env, self) {
        const token = tokens[idx];
        const content = token.content;
        const lang = token.info.trim();
        
        if (lang && window.hljs?.getLanguage(lang)) {
            return `<pre><code class="hljs language-${lang}">${window.hljs.highlight(content, { language: lang }).value}</code></pre>`;
        }
        // Use md.render() for block-level content, wrapped once
        return `<div class="markdown-content">${md.render(content)}</div>`;
    };

    // Customize list rendering for different levels
    md.renderer.rules.list_item_open = function (tokens, idx, options, env, self) {
        const token = tokens[idx];
        const level = env.listLevel || 0; // Track nesting level
        let className = 'markdown-list'; // Default for level 0
        if (level === 1) className = 'nested-list-level1';
        else if (level > 1) className = 'nested-list-level2';
        return `<li class="${className}">`;
    };

    // TABLE
    // Add this after the existing renderer rules
    md.renderer.rules.table_open = function (tokens, idx, options, env, self) {
        return '<table class="markdown-table">';
    };

    md.renderer.rules.table_close = function (tokens, idx, options, env, self) {
        return '</table>';
    };

    md.renderer.rules.th_open = function (tokens, idx, options, env, self) {
        return '<th class="markdown-th">';
    };

    md.renderer.rules.td_open = function (tokens, idx, options, env, self) {
        return '<td class="markdown-td">';
    };

    function formatCodeBlock(code, lang) {
        if (!code.trim()) return '';
        
        if (lang && window.hljs?.getLanguage(lang)) {
            return `<pre><code class="hljs language-${lang}">${window.hljs.highlight(code.trim(), { language: lang }).value}</code></pre>`;
        }
        
        // Wrap markdown-rendered content in a div with margin-left
        return `<div class="markdown-content">${md.render(code.trim())}</div>`;
    }

    function formatChunk(text, codeBuffer, inCodeBlock, lang) {
        if (inCodeBlock) {
            return formatCodeBlock(codeBuffer, lang);
        }
        return text.trim() ? md.render(text.trim()) : '';
    }

    /*
    * Title: Function for set global variable
    * Description: 
    * Set variable: conversationId,
    * 
    */

    // Get conversationId from URL instead of generating randomly
    function getConversationId_fromURL() {
        const url = window.location.href;
        const urlObj = new URL(url);
        const pathSegments = urlObj.pathname.split('/');

        // Check if the URL matches the expected pattern: /chat/conversations/{id}
        if (pathSegments.length >= 4 && 
            pathSegments[1] === 'chat' && 
            pathSegments[2] === 'conversations') {
            return pathSegments[3]; // Return the ID part
        }
        
        // Return empty string or null if pattern doesn't match
        return '';
    }

    /*
    * Title: Global variable
    * Description: 
    * Use: 
    * 
    */
    let isStreaming = false;
    let chatHistory = [];
    let isAutoScroll = true; // Now indicates if auto-scrolling is enable
    let conversationId = getConversationId_fromURL();

    /*
    * Title: Global Element(Div)
    * Description: get, create, append Element
    * Use: 
    * 
    */
    const elements = {
        chatContainer: document.getElementById("chatContainer"),
        chatMessage: document.getElementById("chatMessage"),
        showMessage: document.getElementById("showMessage"),
        userPrompt: document.getElementById("userPrompt"),
        toggleButton: document.getElementById("toggleButton"),
        chatInput: document.getElementById("chatInput"),
        scrollToBottomBtn: document.getElementById("scrollToBottomBtn"), // New element
    };  

    let startButtonSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 19V5" />
                            <polyline points="5 12 12 5 19 12" />
                        </svg>`;
    let stopButtonSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="2" y="2" width="20" height="20" rx="2" ry="2" stroke="currentColor" stroke-width="2" fill="none" />
                        </svg>`;

    // Create Message Element for role=user
    function createUserMessage(userPrompt) {
        const userDiv = document.createElement("div");
        userDiv.className = "user";
        userDiv.innerHTML = `<div class="role_box">${userPrompt}</div>`;
        return userDiv;
    }

    // Create Message Element for role=model
    function createModelMessage() {
        const modelDiv = document.createElement("div");
        modelDiv.className = "model";
        modelDiv.style.minHeight = "calc(100vh - 330px)";
        modelDiv.innerHTML = `<div class="role_box">
            <div class="loading">
                <span>L</span><span>o</span><span>a</span><span>d</span><span>i</span><span>n</span><span>g</span>
                <span>.</span><span>.</span><span>.</span>
            </div>
        </div>`;
        return modelDiv;
    }

    /*
    * Title: Function for Gemini API
    * Description: fetch data from api (AI) by stream(chunk)
    * Fuction: toggleChat, streamResponse=>(readStream), stopStream, handleStreamError, resetChatState
    * Use globle variable: isStreaming,
    * 
    */
    function toggleChat() {
        if (!isStreaming) {
            const userPrompt = elements.userPrompt.value.trim();
            if (!userPrompt) {
                alert("Please type a message to start the chat.");
                return;
            }

            const userMessage = { role: "user", content: userPrompt };
            // chat_history.push(userMessage);
            setChatHistory([userMessage])
            saveMessageDB(senderRole="user", userPrompt, userPrompt);

            isStreaming = true;
            // elements.toggleButton.textContent = "Stop Chat";
            elements.toggleButton.innerHTML = stopButtonSvg;
            elements.userPrompt.disabled = true;

            // Create message elements
            const userDiv = createUserMessage(userPrompt);
            const modelDiv = createModelMessage();
            // Append html inside modelDiv
            const modelContent = modelDiv.querySelector(".role_box");

            // Check if there are any existing children (remove min-height from the last modelDev)
            if (elements.showMessage.children.length > 0) {
                // Find the last child1 and remove its min-height
                let existingModelDiv = elements.showMessage.querySelector('.model:last-of-type');
                if (existingModelDiv) {
                    existingModelDiv.style.minHeight = '';
                }
            }

            // Append both children
            elements.showMessage.appendChild(userDiv);
            elements.showMessage.appendChild(modelDiv);
            

            scrollToBottomManually()
            streamResponse(userPrompt, modelContent);
            // Clear the textarea after starting the stream
            elements.userPrompt.value = "";  // Add this line
            adjustHeights();  // Adjust the height after clearing to reset textarea size
        } else {
            stopStream();
            isStreaming = false;
        }
    }

    function streamResponse(userPrompt, modelContent) {
        fetch("/stream", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({ userPrompt }), 
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let renderedContent = '';
            let codeBlockBuffer = '';
            let tableBuffer = '';
            let isInCodeBlock = false;
            let isInTable = false;
            let codeBlockLang = '';
            let fullResponseText = ''; // To store complete response text

            function renderPartialTable(tableContent) {
                // Split table into lines and ensure we have at least header and separator
                const lines = tableContent.trim().split('\n');
                if (lines.length < 2 || !lines[1].includes('---')) {
                    return tableContent; // Not enough for a valid table yet
                }
                return md.render(tableContent);
            }

            async function readStream() {
                reader.read().then(async ({ done, value }) => {
                    if (done) {
                        if (buffer || codeBlockBuffer || tableBuffer) {
                            if (isInTable) {
                                renderedContent += renderPartialTable(tableBuffer);
                            } else if (isInCodeBlock) {
                                renderedContent += formatCodeBlock(codeBlockBuffer, codeBlockLang);
                            } else {
                                renderedContent += md.render(buffer);
                            }
                            modelContent.innerHTML = renderedContent;
                        }
                        const modelMessage = { role: "model", content: renderedContent };
                        setChatHistory([modelMessage]);

                        // Save to database when stream is complete
                        saveMessageDB(senderRole="model", renderedContent, fullResponseText);

                        // Place updateConversationTitle here
                        if (elements.showMessage.children.length === 2) {

                            // Check if first child has class "user"
                            const firstChild = elements.showMessage.children[0];
                            if (firstChild.classList.contains("user")) {
                                const conversationId = getConversationId_fromURL();
                                const newPrompt = firstChild.textContent.trim(); // Get text from user div instead of userPrompt input
                                await updateConversationTitle(conversationId, newPrompt);
                               
                            }
                        }

                        resetChatState();
                        scrollToBottomByStream();
                        return;
                    }


                    const chunk = decoder.decode(value, { stream: true });
                    fullResponseText += chunk; // Accumulate full response text

                    buffer += chunk;
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    lines.forEach(line => {
                        // Handle code blocks
                        if (line.trim().startsWith('```')) {
                            if (isInCodeBlock) {
                                // End of code block
                                renderedContent += formatCodeBlock(codeBlockBuffer, codeBlockLang);
                                codeBlockBuffer = '';
                                isInCodeBlock = false;
                                codeBlockLang = '';
                            } else {
                                // Start of code block
                                if (tableBuffer) {
                                    renderedContent += renderPartialTable(tableBuffer);
                                    tableBuffer = '';
                                    isInTable = false;
                                } else if (buffer.trim()) {
                                    renderedContent += md.render(buffer.trim());
                                }
                                isInCodeBlock = true;
                                codeBlockLang = line.replace('```', '').trim();
                                codeBlockBuffer = '';
                            }
                        }
                        // Handle tables
                        else if (!isInCodeBlock && (line.includes('|') || line.includes('---'))) {
                            if (!isInTable && line.includes('|')) {
                                isInTable = true;
                            }
                            if (isInTable) {
                                tableBuffer += line + '\n';
                                // Render partial table if we have header and separator
                                if (tableBuffer.includes('---')) {
                                    modelContent.innerHTML = renderedContent + renderPartialTable(tableBuffer);
                                }
                            }
                        }
                        else if (isInCodeBlock) {
                            codeBlockBuffer += line + '\n';
                        }
                        else {
                            if (tableBuffer) {
                                renderedContent += renderPartialTable(tableBuffer);
                                tableBuffer = '';
                                isInTable = false;
                            }
                            renderedContent += md.render(line);
                            modelContent.innerHTML = renderedContent;
                        }
                        scrollToBottomByStream();
                    });

                    // Update display with current content
                    if (isInTable && tableBuffer.includes('---')) {
                        modelContent.innerHTML = renderedContent + renderPartialTable(tableBuffer);
                    } else if (!isInCodeBlock && !isInTable) {
                        modelContent.innerHTML = renderedContent;
                    }

                    readStream();
                }).catch(err => handleStreamError(err, modelContent));
            }
            readStream();
        })
        .catch(err => handleStreamError(err, modelContent));
    }

    function handleStreamError(err, modelContent) {
        console.error("Stream error:", err);
        modelContent.innerHTML += "<p style='color: red;'>Error: Stream interrupted.</p>";
        resetChatState();
    }

    function resetChatState() {
        isStreaming = false;
        // elements.toggleButton.textContent = "Start Chat";
        elements.toggleButton.innerHTML = startButtonSvg;
        elements.userPrompt.disabled = false;
        elements.toggleButton.disabled = !elements.userPrompt.value.trim() && !isStreaming; // Disable if empty and not streaming
    }

    /*
    * Title: Controll Function for Backend
    * Description: 
    * Use: 
    * 
    */
    function stopStream() {
        fetch("/stop", { method: "POST" })
            .then(res => res.json())
            .then(data => console.log("Stop response:", data))
            .catch(err => console.error("Stop error:", err));
        resetChatState();
    }

    async function setChatHistory(newMessages) {
        try {
            const response = await fetch("/set_chat_history", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ chat_history: newMessages })
            });
            const data = await response.json();
            console.log('Server response:', data);
        } catch (error) {
            console.error('Error setting chat history:', error);
        }
    }

    function clearChat() {
        fetch("/clear_history", { method: "POST" })
            .then(response => response.json())
            .catch(err => console.error("Clear error:", err))
            .then(() => elements.showMessage.innerHTML = "");
    }

   /*
    * Title: Database
    * Description: 
    * Use global variable: conversationId,
    * Body: JSON.stringify({})
    */

    async function getConversation(conversationId) {
        try {
            const response = await fetch(`/api/chat/conversations/${conversationId}`, {
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'include' // Include cookies for authentication
            });

            const data = await response.json();

            if (data.status === 'error') {
                // showError(data.message);
                return;
            }

            // console.log("get converation data:", data)
            
            data.messages.forEach(message => {
                const messageElement = document.createElement('div');
                messageElement.classList.add('message', 
                    message.sender === 'user' ? 'user' : 'model');
                
                messageElement.innerHTML = `
                    <div class="role_box">
                        ${ message.sender === 'user' ? message.message_text : message.message_html }
                    </div>`;
                
                showMessage.appendChild(messageElement);
            });

            // displayMessages(data.messages, data.current_user);
        } catch (error) {
            // showError('Failed to load conversation');
            console.error('Error:', error);
        }
    }

    // First Create conversation (ID)
    async function createConversationDB_id() {
        try {
            const response = await fetch('/api/create_conversation', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            
            if (data.status === 'success') {
                console.log("Conversation:", data);
                // return data.conversation_id;
                return data.id;
            }
            throw new Error('Failed to create conversation ID');
            
        } catch (error) {
            console.error('Error creating conversation ID:', error);
            return null;
        }
    }

    async function updateConversationTitle(conversationId, newPrompt) {
        try {
            console.log('Sending request:', { conversationId, newPrompt });
            const response = await fetch('/api/update_conversation_title', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    conversation_id: conversationId, // UUID or DB ID
                    userPrompt: newPrompt
                }),
                credentials: 'include' // Add this if using sessions
            });

            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }

            const data = await response.json();
            console.log("datatsss", data)

            if (data.status === 'success') {
                console.log(`Conversation title set to: ${data.title}`);
                // document.getElementById("titleResult").innerHTML = `<h2>${data.title}</h2>`;
                const containerFromLayout = document.getElementById('conversations-container2');
                containerFromLayout.innerHTML = `<ul><li><a href="/chat/conversations/${data.id}">${data.title}</a></li></ul>`;
                // return {
                //     conversationId: data.id,
                //     title: data.title
                // };
            }

        } catch (error) {
            console.error('Error updating conversation title:', error);
            return null; // Or throw the error if preferred
        }
    }

    // Save data to database
    async function saveMessageDB(senderRole, fullResponseText, renderContent) {
    
        // If conversationId is empty or not found, create a new one
        if (!conversationId || conversationId === '') {
            conversationId = await createConversationDB_id();
            if (!conversationId) {
                console.error('Failed to create conversation ID');
                return false;
            }
            // Optionally update URL with new conversation ID
            window.history.pushState({}, '', `/chat/conversations/${conversationId}`);
        }

        const messageData = {
            conversionID: conversationId,
            sender: senderRole,
            fullResponseText: fullResponseText,
            renderContent:renderContent
        };

        try {
            const response = await fetch('/api/save_chat_history', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    chat_history: [messageData]
                })
            });

            const data = await response.json();
            
            if (data.status === 'success') {
                return true;
            }
            throw new Error('Server error');
        } catch (error) {
            console.error('Error saving message:', error);
            return false;
        }
    }
    
    /*
    * Title: Chat Behavior
    * Description: 
    * Use: 
    * 
    */

    // Modified scrollToBottomByStream function
    function scrollToBottomByStream() {
        if (isAutoScroll) { 
            elements.chatMessage.scrollTo({
                top: elements.chatMessage.scrollHeight,
                behavior: 'smooth'
            });
        }
    }

    // Modified scrollToBottomManually function
    function scrollToBottomManually() {
        elements.chatMessage.scrollTo({
            top: elements.chatMessage.scrollHeight,
            behavior: 'smooth'
        });
    }

    function adjustHeights() {
        const textarea = elements.userPrompt;
        let maxHeight = 200; // Set any value you want
        textarea.style.height = "25px";
        textarea.style.height = `${Math.min(textarea.scrollHeight + 10, maxHeight)}px`;

        const containerHeight = elements.chatContainer.clientHeight;
        elements.chatMessage.style.height = `${containerHeight - elements.chatInput.offsetHeight}px`;
    }

    /*
    * Title: DOMContentLoaded
    * Description: 
    * Use: 
    * 
    */

    document.addEventListener("DOMContentLoaded", async () => {

        adjustHeights()
        scrollToBottomManually()

        if (conversationId) {
            getConversation(conversationId);
        }

        // Initially disable toggleButton if textarea is empty and not streaming
        elements.toggleButton.disabled = !elements.userPrompt.value.trim() && !isStreaming;

        // Add input event listener to enable/disable toggleButton based on textarea content and streaming state
        elements.userPrompt.addEventListener("input", () => {
            elements.toggleButton.disabled = !elements.userPrompt.value.trim() && !isStreaming; // Only disable if empty and not streaming
            adjustHeights();
        });

        elements.userPrompt.addEventListener("input", adjustHeights);
        elements.userPrompt.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && !e.shiftKey && !isStreaming) {
                e.preventDefault();
                toggleChat();
            }
        });
        elements.chatInput.addEventListener("click", () => elements.userPrompt.focus());

        elements.chatMessage.addEventListener("scroll", () => {
            const chat = elements.chatMessage;
            const distanceFromBottom = chat.scrollHeight - chat.scrollTop - chat.clientHeight;

            // is at Bottom from 10px
            if (distanceFromBottom < 10) {
                isAutoScroll = true; // Disable auto-scroll when user scrolls up
            } else {
                isAutoScroll = false;
            }

            // is at Bottom from 200px
            if (distanceFromBottom < 200) {
                elements.scrollToBottomBtn.style.display = "none";
            } else {
                elements.scrollToBottomBtn.style.display = "inline-flex";
            }
        });

        
    });
</script>

{% endblock %}

