{% extends "layout.html" %}

{% block title %}Dynamic Chat UI{% endblock %}

{% block script %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<style>
    .chat_container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 100px); /* Full viewport height */
        /* height: calc(100% - 100px); */
    }

    /* box 01 */
    .scrollable_chat {
        flex-grow: 1; /* Takes available space */
        overflow-y: auto; /* Makes it scrollable */
        /* background-color: lightblue; */
        padding: 10px 20px;
    }
    .chat_content{
        /* background-color: rgb(143, 226, 143); */
        /* max-width: 720px; */
        max-width: 48rem;
        margin: auto;
    }

    /* box 02 */
    .chat_input {
        /* background-color: steelblue; */
        cursor: text; /* Indicates text input */
        padding: 0 20px;
        
    }
    .chat_box_content{
        background-color: aliceblue;
        /* max-width: 720px; */
        max-width: 48rem;
        margin: auto;
        border: 1px darkgray solid;
        border-radius: 20px;
        overflow: hidden;
        padding: 10px 20px;
    }
    .text_box {
        width: 100%;
        height: auto;
        resize: none;
        overflow-x: hidden;
        overflow-y: auto;
        padding: 0;
        border: none;
        outline: none;
        line-height: 20px;
        font-size: 16px;
        line-height: 1.5;
        margin: 10px 0;
        background-color: aliceblue;
    }
    /* Make the scrollbar thin */
    .text_box::-webkit-scrollbar {
        width: 6px; /* Adjust the width */
        height: 6px; /* For horizontal scrollbars */
    }
    .text_box::-webkit-scrollbar-track {
        background: #f1f1f1; /* Light gray background */
        border-radius: 10px;
    }

    /* Scrollbar Thumb (draggable part) */
    .text_box::-webkit-scrollbar-thumb {
        background: #888; /* Darker gray */
        border-radius: 10px;
        cursor: grab; /* Makes the scrollbar draggable */
    }

    /* On hover, make the thumb slightly darker */
    .text_box::-webkit-scrollbar-thumb:hover {
        background: #555;
        cursor: grabbing; /* When actively dragging */
    }

    /* Style on chat */
    .user{
        display: flex;
        justify-content: end;
        margin-bottom: 20px;
        
    }
    .user > div{
        background-color: goldenrod;
        border-radius: 20px;
        padding: 10px 20px;
    }
    .model{
        margin-bottom: 20px;
    }

    /* Action */
    .action_button_container{
        display: flex;
        justify-content: space-between;
    }
    .btn_custom{
        border: 0.1px solid gray;
        background-color: burlywood;
        border-radius: 20px;
        padding: 5px 15px;
    }

    .loading {
            /* font-size: 2rem; */
            /* font-weight: bold; */
            display: flex;
        }
        .loading span {
            animation: blink 1.5s infinite;
        }
        .loading span:nth-child(1) { animation-delay: 0s; }
        .loading span:nth-child(2) { animation-delay: 0.2s; }
        .loading span:nth-child(3) { animation-delay: 0.4s; }
        .loading span:nth-child(4) { animation-delay: 0.6s; }
        .loading span:nth-child(5) { animation-delay: 0.8s; }
        .loading span:nth-child(6) { animation-delay: 1s; }
        .loading span:nth-child(7) { animation-delay: 1.2s; }
        .loading span:nth-child(8) { animation-delay: 1.4s; }
        .loading span:nth-child(9) { animation-delay: 1.6s; }

        @keyframes blink {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .scroll-to-bottom {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden by default */
            z-index: 10; /* Ensure it’s above other content */
            border: 0.1px solid gray;
            border-radius: 20px;
            padding: 5px 15px;
            cursor: pointer;
        }
        .scroll-to-bottom svg {
            vertical-align: middle;
        }

    /* For the mark-down */
    .markdown-content {
        margin-left: 20px;
    }
    /* .markdown-content ul li::marker {
        content: "➤  "; 
        color: #333;
    } */
    .markdown-content>div ul li::marker {
        content: "❖  ";
        color: #333;
    }
    .markdown-content>div>div ul li::marker {
        content: "-  ";
        color: #333;
    }

    /* Table */
    .markdown-content ol li::marker {
        content: counter(list-item) ". "; /* Keeps numbers, or replace with a symbol */
        color: #333;
    }

    .markdown-table {
        border-collapse: collapse;
        margin: 1em 0;
        width: 100%;
    }
    .markdown-th, .markdown-td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
    }
    .markdown-th {
        background-color: #f5f5f5;
        font-weight: bold;
    }
   
</style>
{% endblock %}

{% block content %}
<div class="chat_container">

    <div style="position: relative;">

        <div id="chatMessage" class="scrollable_chat">
            <div class="chat_content">
                <div class=" text-center mb-4" >
                    <h1>How can I help you today?</h1>
            
                </div> 
                <div id="showMessage">
                    {% for message in chat_history %}
                        <div class="{{ message.role }}">
                            <div class="role_box">
                                <!-- For text use this => {{ message.content }} -->
                                <!-- For html user this => {{ message.content | safe}} -->
                                <!-- <strong>{{ message.role|capitalize }}:</strong>  -->
                                {{ message.content | safe}}
                            </div>
                        </div>
                    {% endfor %}
                </div>
            </div>  
        </div>

        <!-- Add Scroll to Bottom button here -->
        <button id="scrollToBottomBtn" class="btn btn-sm btn-primary p-1 scroll-to-bottom" onclick="scrollToBottomManually()">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 5v14" />
                <polyline points="19 12 12 19 5 12" />
            </svg>
            <!-- Scroll to Bottom -->
        </button>

    </div>

    <div id="chatInput" class="chat_input" onclick="focusInput()">

        <div class="chat_box_content">
            <textarea id="prompt" class="text_box"  rows="1" placeholder="Type something..."></textarea>
            <div class="action_button_container">
                <div class="action1">
                    <button class="btn btn-sm btn-primary" onclick="addEditableForm()">Prompts</button>
                </div>
                <div class="action2">
                    <button id="toggleButton" class="btn btn-sm btn-primary" onclick="toggleChat()">
                        <!-- Start Chat -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 19V5" />
                            <polyline points="5 12 12 5 19 12" />
                        </svg>
                    </button>
                    <!-- <button class="btn" onclick="clearChat()">Clear chat</button> -->
                </div>
            </div>
        </div>

    </div>
</div>


<!-- <script>
    // conversation.js
    document.addEventListener('DOMContentLoaded', () => {
        fetchConversationMessages(conversationId);
    });

    function fetchConversationMessages(conversationId) {
        const messagesList = document.getElementById('showMessage');

        fetch(`/api/users/conversations/${conversationId}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            },
            credentials: 'same-origin'  // Include cookies/session info
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // Clear loading message
            messagesList.innerHTML = '';

            if (data.status === 'success') {
                // Render messages
                data.messages.forEach(message => {
                    const messageDiv = document.createElement('div');
                    messageDiv.classList.add('message', message.sender);  // Add 'user' or 'ai' class
                    messageDiv.innerHTML = `
                        <strong>${message.sender.toUpperCase()}:</strong> 
                        ${message.message_text}
                        <br>
                        <small>${new Date(message.timestamp).toLocaleString()}</small>
                        ${message.api_response_time ? `<br><small>Response time: ${message.api_response_time}s</small>` : ''}
                    `;
                    messagesList.appendChild(messageDiv);
                });

                if (data.messages.length === 0) {
                    messagesList.innerHTML = '<p>No messages in this conversation yet.</p>';
                }
            } else {
                messagesList.innerHTML = `<p class="error">Error: ${data.message}</p>`;
            }
        })
        .catch(error => {
            console.error('Error fetching messages:', error);
            messagesList.innerHTML = '<p class="error">Failed to load messages. Please try again later.</p>';
        });
    }
</script> -->


<!-- <script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.2/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/core.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>

<script>
    const md = window.markdownit({
        html: true,
        breaks: true,
        highlight: function (str, lang) {
            if (lang && window.hljs?.getLanguage(lang)) {
                // If a valid language is detected, format as highlighted code
                return `<pre><code class="hljs">${window.hljs.highlight(str, { language: lang }).value}</code></pre>`;
            }
            // Return null to bypass default code block rendering
            return null;
        }
    });

    // LIST
    // Override the default code_block and fence rendering
    md.renderer.rules.code_block = function (tokens, idx, options, env, self) {
        const token = tokens[idx];
        const content = token.content;
        // Use md.render() for block-level content, wrapped once
        return `<div class="markdown-content">${md.render(content)}</div>`;
    };

    md.renderer.rules.fence = function (tokens, idx, options, env, self) {
        const token = tokens[idx];
        const content = token.content;
        const lang = token.info.trim();
        
        if (lang && window.hljs?.getLanguage(lang)) {
            return `<pre><code class="hljs language-${lang}">${window.hljs.highlight(content, { language: lang }).value}</code></pre>`;
        }
        // Use md.render() for block-level content, wrapped once
        return `<div class="markdown-content">${md.render(content)}</div>`;
    };

    // Customize list rendering for different levels
    md.renderer.rules.list_item_open = function (tokens, idx, options, env, self) {
        const token = tokens[idx];
        const level = env.listLevel || 0; // Track nesting level
        let className = 'markdown-list'; // Default for level 0
        if (level === 1) className = 'nested-list-level1';
        else if (level > 1) className = 'nested-list-level2';
        return `<li class="${className}">`;
    };

    // TABLE
    // Add this after the existing renderer rules
    md.renderer.rules.table_open = function (tokens, idx, options, env, self) {
        return '<table class="markdown-table">';
    };

    md.renderer.rules.table_close = function (tokens, idx, options, env, self) {
        return '</table>';
    };

    md.renderer.rules.th_open = function (tokens, idx, options, env, self) {
        return '<th class="markdown-th">';
    };

    md.renderer.rules.td_open = function (tokens, idx, options, env, self) {
        return '<td class="markdown-td">';
    };

    function formatCodeBlock(code, lang) {
        if (!code.trim()) return '';
        
        if (lang && window.hljs?.getLanguage(lang)) {
            return `<pre><code class="hljs language-${lang}">${window.hljs.highlight(code.trim(), { language: lang }).value}</code></pre>`;
        }
        
        // Wrap markdown-rendered content in a div with margin-left
        return `<div class="markdown-content">${md.render(code.trim())}</div>`;
    }

    function formatChunk(text, codeBuffer, inCodeBlock, lang) {
        if (inCodeBlock) {
            return formatCodeBlock(codeBuffer, lang);
        }
        return text.trim() ? md.render(text.trim()) : '';
    }

    // Set global variable
    let isStreaming = false;
    let chatHistory = [];
    let isAutoScroll = true; // Now indicates if auto-scrolling is enabled

    const elements = {
        chatMessage: document.getElementById("chatMessage"),
        showMessage: document.getElementById("showMessage"),
        prompt: document.getElementById("prompt"),
        toggleButton: document.getElementById("toggleButton"),
        chatInput: document.getElementById("chatInput"),
        scrollToBottomBtn: document.getElementById("scrollToBottomBtn"), // New element
    };  

    let startButtonSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 19V5" />
                            <polyline points="5 12 12 5 19 12" />
                        </svg>`;
    let stopButtonSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="2" y="2" width="20" height="20" rx="2" ry="2" stroke="currentColor" stroke-width="2" fill="none" />
                        </svg>`;

    // Create Message Element for role=user
    function createUserMessage(prompt) {
        const userDiv = document.createElement("div");
        userDiv.className = "user";
        userDiv.innerHTML = `<div class="role_box">${prompt}</div>`;
        return userDiv;
    }

    // Create Message Element for role=model
    function createModelMessage() {
        const modelDiv = document.createElement("div");
        modelDiv.className = "model";
        modelDiv.style.minHeight = "calc(100vh - 330px)";
        modelDiv.innerHTML = `<div class="role_box">
            <div class="loading">
                <span>L</span><span>o</span><span>a</span><span>d</span><span>i</span><span>n</span><span>g</span>
                <span>.</span><span>.</span><span>.</span>
            </div>
        </div>`;
        return modelDiv;
    }

    function toggleChat() {
        if (!isStreaming) {
            const prompt = elements.prompt.value.trim();
            if (!prompt) {
                alert("Please type a message to start the chat.");
                return;
            }

            const userMessage = { role: "user", content: prompt };
            // chat_history.push(userMessage);
            setChatHistory([userMessage])

            isStreaming = true;
            // elements.toggleButton.textContent = "Stop Chat";
            elements.toggleButton.innerHTML = stopButtonSvg;
            elements.prompt.disabled = true;

            // Create message elements
            const userDiv = createUserMessage(prompt);
            const modelDiv = createModelMessage();
            // Append html inside modelDiv
            const modelContent = modelDiv.querySelector(".role_box");

            // Check if there are any existing children (remove min-height from the last modelDev)
            if (elements.showMessage.children.length > 0) {
                // Find the last child1 and remove its min-height
                let existingModelDiv = elements.showMessage.querySelector('.model:last-of-type');
                if (existingModelDiv) {
                    existingModelDiv.style.minHeight = '';
                }
            }

            // Append both children
            elements.showMessage.appendChild(userDiv);
            elements.showMessage.appendChild(modelDiv);
            

            scrollToBottomManually()
            streamResponse(prompt, modelContent);
            // Clear the textarea after starting the stream
            elements.prompt.value = "";  // Add this line
            adjustHeights();  // Adjust the height after clearing to reset textarea size
        } else {
            stopStream();
            isStreaming = false;
        }
    }

    function streamResponse(prompt, modelContent) {
        fetch("/stream", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({ prompt }), 
        })
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let renderedContent = '';
            let codeBlockBuffer = '';
            let tableBuffer = '';
            let isInCodeBlock = false;
            let isInTable = false;
            let codeBlockLang = '';

            function renderPartialTable(tableContent) {
                // Split table into lines and ensure we have at least header and separator
                const lines = tableContent.trim().split('\n');
                if (lines.length < 2 || !lines[1].includes('---')) {
                    return tableContent; // Not enough for a valid table yet
                }
                return md.render(tableContent);
            }

            function readStream() {
                reader.read().then(({ done, value }) => {
                    if (done) {
                        if (buffer || codeBlockBuffer || tableBuffer) {
                            if (isInTable) {
                                renderedContent += renderPartialTable(tableBuffer);
                            } else if (isInCodeBlock) {
                                renderedContent += formatCodeBlock(codeBlockBuffer, codeBlockLang);
                            } else {
                                renderedContent += md.render(buffer);
                            }
                            modelContent.innerHTML = renderedContent;
                        }
                        const modelMessage = { role: "model", content: renderedContent };
                        setChatHistory([modelMessage]);
                        resetChatState();
                        scrollToBottomByStream();
                        return;
                    }

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    lines.forEach(line => {
                        // Handle code blocks
                        if (line.trim().startsWith('```')) {
                            if (isInCodeBlock) {
                                // End of code block
                                renderedContent += formatCodeBlock(codeBlockBuffer, codeBlockLang);
                                codeBlockBuffer = '';
                                isInCodeBlock = false;
                                codeBlockLang = '';
                            } else {
                                // Start of code block
                                if (tableBuffer) {
                                    renderedContent += renderPartialTable(tableBuffer);
                                    tableBuffer = '';
                                    isInTable = false;
                                } else if (buffer.trim()) {
                                    renderedContent += md.render(buffer.trim());
                                }
                                isInCodeBlock = true;
                                codeBlockLang = line.replace('```', '').trim();
                                codeBlockBuffer = '';
                            }
                        }
                        // Handle tables
                        else if (!isInCodeBlock && (line.includes('|') || line.includes('---'))) {
                            if (!isInTable && line.includes('|')) {
                                isInTable = true;
                            }
                            if (isInTable) {
                                tableBuffer += line + '\n';
                                // Render partial table if we have header and separator
                                if (tableBuffer.includes('---')) {
                                    modelContent.innerHTML = renderedContent + renderPartialTable(tableBuffer);
                                }
                            }
                        }
                        else if (isInCodeBlock) {
                            codeBlockBuffer += line + '\n';
                        }
                        else {
                            if (tableBuffer) {
                                renderedContent += renderPartialTable(tableBuffer);
                                tableBuffer = '';
                                isInTable = false;
                            }
                            renderedContent += md.render(line);
                            modelContent.innerHTML = renderedContent;
                        }
                        scrollToBottomByStream();
                    });

                    // Update display with current content
                    if (isInTable && tableBuffer.includes('---')) {
                        modelContent.innerHTML = renderedContent + renderPartialTable(tableBuffer);
                    } else if (!isInCodeBlock && !isInTable) {
                        modelContent.innerHTML = renderedContent;
                    }

                    readStream();
                }).catch(err => handleStreamError(err, modelContent));
            }
            readStream();
        })
        .catch(err => handleStreamError(err, modelContent));
    }

    function handleStreamError(err, modelContent) {
        console.error("Stream error:", err);
        modelContent.innerHTML += "<p style='color: red;'>Error: Stream interrupted.</p>";
        resetChatState();
    }

    function stopStream() {
        fetch("/stop", { method: "POST" })
            .then(res => res.json())
            .then(data => console.log("Stop response:", data))
            .catch(err => console.error("Stop error:", err));
        resetChatState();
    }

    async function setChatHistory(newMessages) {
        try {
            const response = await fetch("/set_chat_history", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ chat_history: newMessages })
            });
            const data = await response.json();
            console.log('Server response:', data);
        } catch (error) {
            console.error('Error setting chat history:', error);
        }
    }

    function resetChatState() {
        isStreaming = false;
        // elements.toggleButton.textContent = "Start Chat";
        elements.toggleButton.innerHTML = stopButtonSvg;
        elements.prompt.disabled = false;
        elements.toggleButton.disabled = !elements.prompt.value.trim() && !isStreaming; // Disable if empty and not streaming
    }

    function clearChat() {
        fetch("/clear_history", { method: "POST" })
            .then(response => response.json())
            .catch(err => console.error("Clear error:", err))
            .then(() => elements.showMessage.innerHTML = "");
    }
    
    // Modified scrollToBottomByStream function
    function scrollToBottomByStream() {
        if (isAutoScroll) { 
            elements.chatMessage.scrollTo({
                top: elements.chatMessage.scrollHeight,
                behavior: 'smooth'
            });
        }
    }

    // Modified scrollToBottomManually function
    function scrollToBottomManually() {
        elements.chatMessage.scrollTo({
            top: elements.chatMessage.scrollHeight,
            behavior: 'smooth'
        });
    }

    function adjustHeights() {
        const textarea = elements.prompt;
        let maxHeight = 200; // Set any value you want
        textarea.style.height = "25px";
        textarea.style.height = `${Math.min(textarea.scrollHeight + 10, maxHeight)}px`;
        const containerHeight = document.querySelector(".chat_container").clientHeight;
        elements.chatMessage.style.height = `${containerHeight - elements.chatInput.offsetHeight}px`;
    }

    document.addEventListener("DOMContentLoaded", () => {

        adjustHeights()
        scrollToBottomManually()

        // Initially disable toggleButton if textarea is empty and not streaming
        elements.toggleButton.disabled = !elements.prompt.value.trim() && !isStreaming;

        // Add input event listener to enable/disable toggleButton based on textarea content and streaming state
        elements.prompt.addEventListener("input", () => {
            elements.toggleButton.disabled = !elements.prompt.value.trim() && !isStreaming; // Only disable if empty and not streaming
            adjustHeights();
        });

        elements.prompt.addEventListener("input", adjustHeights);
        elements.prompt.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && !e.shiftKey && !isStreaming) {
                e.preventDefault();
                toggleChat();
            }
        });
        elements.chatInput.addEventListener("click", () => elements.prompt.focus());

        elements.chatMessage.addEventListener("scroll", () => {
            const chat = elements.chatMessage;
            const distanceFromBottom = chat.scrollHeight - chat.scrollTop - chat.clientHeight;

            // is at Bottom from 10px
            if (distanceFromBottom < 10) {
                isAutoScroll = true; // Disable auto-scroll when user scrolls up
            } else {
                isAutoScroll = false;
            }

            // is at Bottom from 200px
            if (distanceFromBottom < 200) {
                elements.scrollToBottomBtn.style.display = "none";
            } else {
                elements.scrollToBottomBtn.style.display = "inline-flex";
            }
        });

    });
</script> -->

{% endblock %}

